/*
bcrypt = Promise.promisifyAll(require('bcrypt-nodejs'))
crypto = Promise.promisifyAll require 'crypto'
Mail = Promise.promisifyAll require '../../services/mail'
*/


const crypto = require('crypto');

const moment = require('moment');

module.exports = function(bookshelf) {
  global.Token = bookshelf.Model.extend({
    tableName: 'tokens',
    hasTimestamps: true,
    visible: ['key', 'created_at'],
    virtuals: {
      key: function() {
        return this.unhashedKey;
      }
    },
    initialize: function() {
      return this.on('creating', function(model, attrs, options) {
        let deferred = Promise.pending();
        model.generateToken(null, function() {
          logger.info('token created');
          return deferred.resolve('token created');
        });
        return deferred.promise;
      });
    },
    tokenable: function() {
      return this.morphTo('tokenable', User);
    },
    generateToken: function(length, next) {
      length || (length = 48);
      console.log('generating token with length', length);
      return crypto.randomBytes(length, (ex, buf)=> {
        console.log('token generated');
        let key = buf.toString("hex");
        self.unhashedKey = key;
        self.set('hashed_key', Token.hash(key));
        return next();
      });
    },
    expired: function(timeLength, timeUnits) {
      if (moment().subtract(timeLength, timeUnits).isAfter(this.get('createdAt'))) {
        return true;
      } else {
        return false;
      }
    }

    /*
toJSON: ->
  key: @get('key')
*/
  }, {
    hash: function(unhashed) {
      return crypto.createHash('sha512').update(unhashed).digest("hex");
    },
    hashAndForge: function(unhashedKey, type) {
      var hashedKey;
      hashedKey = this.hash(unhashedKey);
      return this.forge({
        hashed_key: hashedKey,
        type: type
      });
    }
  });
  return Token;
};

// ---
// generated by coffee-script 1.9.2